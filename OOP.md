# OOP (Object Oriented Programming)

객체지향 프로그래밍과 반대 되는 개념이 구조적 프로그래밍

구조적 프로그래밍의 경우 데이터와 함수가 따로 있기 때문에 스파게티 코드가 되는 경우가 많다. 

객체지향 프로그래밍에서는 프로그램을 클래스의 집합으로 본다. 

다른 구조에 영향이 적기 때문에 타입 추가가 용이하다.

## 중점 요소

1. 필요한 객체

2. 필요한 오퍼레이션

3. 객체끼리 협력 방식

## 객체지향의 클래스와 C의 구조체

객체 지향의 클래스 : 변수와 메소드의 정의 가능

데이터와 함수가 같이 있는 것이 객체 지향 프로그래밍이다. 

## 구조적 프로그래밍 - 기능적 분해 (Functional Decomposition)

복잡함을 다루는 자연스러운 방법 : 문제를 구성하는 기능을 순서대로 분할

미래에 일어날 변경에 대비한 코드를 만들어 주어야 한다.

대부분의 결함은 코드 변경에 의해 일어나는데, 요구 변경 여부와 미래 환경을 알 수 없으므로, 변경을 중단할 수 없기 때문에 변경에 대비해야 한다.

구조적 프로그래밍은 이에 변경을 수용할 수 있는 모듈화를 이용한다.

모든 도형에 대해 일관된 명세를 가진다는 보장이 없음

    [모듈화]
        - 이해 용이성 : 코드 유지보수가 쉬움
        - 발생 가능한 모든 변경을 다루어서는 안된다. : 한 모듈안에 너무 많은 책임은 x

객체지향은 요구 변경에 의한 결과를 최소화 시킨다는 점에서 기능적 분해와 대비됨

## 응집(Cohesion)

루틴 안의 오퍼레이션이 얼마나 긴밀히 관련있는지

## 결합(Coupling)

두 루틴 사이의 연결 강도

## 목표 : 강한 응집과 느슨한 결합

내부 통일성이 있고(강한응집), 다른 루틴과 작고, 직접적이며, 드러나 보이는, 융통성 있는 관계(느슨한 결합)를 가진 루틴을 생성

-> 이를 위해 모듈이 한가지 일만 하게 해야 함

## 원치 않는 파급 효과

원시 코드의 한쪽 함수나 데이터를 변경했을 떄 다른 쪽 코드에 예상치 못한 영향을 주는 경우

## 소프트웨어 개발의 관점

1. 개념적(Conceptual) 수준

    도메인에 있는 개념, 구현되는 소프트웨어와 관계가 없는

2. 명세적(Specification) 수준

    구현이 아닌 소프트웨어의 인터페이스 수준, API 수준

3. 구현적(Implementation) 수준

    원시 코드 수준

    UML을 다룰 때 개념적인 수준에서 구현적인 수준으로 발전하게 된다.

## 객체 중심적 사고법

객체 : 책임을 지닌 것

책임 : 데이터 - 어떤 상태인지 알기 위한 것 / 메소드 - 적절히 동작하기 위한 것

설계 규칙 : 객체는 고유의 책임을 가지게 하고, 그 책임을 명확히 정의 하여야 한다.

1. 개념적 수준

    객체는 "책임"의 집합

2. 명세적 수준

    객체는 다른 객체나 스스로에 의하여 구동될 수 있는 "메소드"의 집합

3. 구현 수준

    객체는 코드와 데이터

## Public 인터페이스

메소드의 모임을 그 객체의 public 인터페이스라고 한다.

객체의 메소드 : 다른 객체에 의하여 호출될 것으로 여겨지는 것

## 클래스 

객체의 동작에 대한 정의. 다음의 명세를 포함한다.

- 객체가 가진 데이터 요소

- 객체가 조작할 메소드

- 데이터 요소와 메소드에 접근하는 방법

객체는 클래스의 인스턴스다.

## 인스턴스

인스턴스는 객체에 포함되는 개념, 구현된 구체적인 실체.

instantiation : 인스턴스를 생성

동일한 타입의 각 객체는 다른 데이터를 가지지만 같은 기능을 가진다.

## 추상클래스

정의하는 클래스. abstract. 슈퍼클래스

이를 구현한, 특수한 타입을 표현한 클래스를 concrete 클래스라고 부름. 서브 클래스

추상클래스는 다른 클래스의 틀이고, 파생된 클래스는 메소드를 구현해야 함. 

모든 파생 클래스에서 사용될 공통 메소드를 정의함

## VIsibility

1. Public : 누구나 접근
2. Protected : 본 클래스와 파생된 클래스 점근
3. Private : 본 클래스의 객체만 접근

## 캡슐화

데이터 숨기기, 일반적으로 모든 타입을 숨김

사용자가 구현 이슈에 대해 걱정할 필요 없음

사용자를 걱정하지 않고 구현 변경 가능

객체의 내부는 외부에 알려지지 않음

### 캡슐화를 하는 이유?

- 객체가 자신의 동작에 많은 책임을 질수록, 컨트롤 프로그램은 책임질 일이 없어진다.

- 객체의 내부 동작에 대한 변경을 다른 객체에 대하여 투명하게 한다.

- 불필요한 변경 효과를 방지한다.

## 다형성 (Polymorphism)

가장 파워풀한 특징

파생된 객체의 타입에 따라 다른 동작을 한다. 다른 객체의 같은 이름의 메소드

## 특수 메소드

생성자 : 객체 생성시 자동 호출, 객체를 시작시킴. 초기화 안된 변수는 제거

소멸자 : 호출시 객체 삭제, 자원 링리스 ex) JAVA의 가비지 콜렉션