# Composite Pattern

<img width="684" alt="image" src="https://user-images.githubusercontent.com/57888020/164046917-73b3f32e-9f4c-409a-93d3-c2ae818630c1.png">

## 협동

클라이언트는 컴포지트 구조에 있는 각 객체들을 이용할때 컴포넌트 인터페이스를 사용한다 

클라이언트가 특정 객체에 어떤 요청을 보내면(함수를 호출하면), 

해당 객체가 리프 객체일 경우엔 직접적으로 그 요청이 처리되고, 

해당 객체가 컴포지트 객체일 경우엔 그 요청은 컴포지트 객체가 가지고 있는 모든 컴포넌트 객체들에게 재전송된다. 

## 구현

1. 부모 객체 참조를 명시

자식 객체에서 부모 객체로의 이동을 위해 부모 참조를 모든 객체마다 가지게 할 수 있다.

이 경우, 부모 참조 변수와 그 관리는 컴포넌트 클래스에서 구현하는 것이 일반적이다.

2. 컴포넌트의 공유

자식 객체들이 독점적으로 한 컴포지트 객체에만 소속되는 것이 아니라 여러 컴포지트 객체들에 동시에 공유될 수 있다.

부모 참조를 유지하려면, 단일 참조가 아닌 복수 참조를 유지관리해야 한다. 

### 자식관리 오퍼레이션 - 컴포넌트에 정의 할? 말?

<img width="481" alt="image" src="https://user-images.githubusercontent.com/57888020/164049416-7775672b-64f7-4ff2-9a9f-9aaefcb72456.png">

만약에 컴포넌트에 자식관리 오퍼레이션을 정의할 거라면 컴포넌트로 인터페이스 보다는 추상 클래스를 사용해야 한다.

인터페이스의 경우, 그 메소드들을 모두 구현해야 하기 때문에 리프 클래스에서 사용하지 않을 자식관리 오퍼레이션도 구현해야하기 때문이다.

## 고려

1. 자식 객체를 어떻게 관리? 
2. 누가 컴포넌트를 삭제할 것인지
  - 자식을 삭제하는 책임은 컴포지트 객체에 주는 것이 좋다.
